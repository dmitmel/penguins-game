<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>penguins: src/bot.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">penguins
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('bot_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bot.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="bot_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBotFloodFillCtx.html">BotFloodFillCtx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="structBotState.html#ad06a633c0dcc623271d461298797a27c" title="Counts all fish accessible within an enclosed area starting at the given point using the flood fill a...">bot_flood_fill_count_fish</a>.  <a href="structBotFloodFillCtx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a187b763475a2ab4f8505b2da8571e17b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a187b763475a2ab4f8505b2da8571e17b">bot_alloc_buf</a>(buf,  capacity,  size)&#160;&#160;&#160;  ((size_t)1 * size &gt; capacity ? (buf = realloc(buf, sizeof(*buf) * size), capacity = size) : 0)</td></tr>
<tr class="memdesc:a187b763475a2ab4f8505b2da8571e17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for allocating the buffers cached within the <a class="el" href="structBotState.html" title="Contains temporary data created during the evaluation of bot&#39;s moves.">BotState</a>.  <a href="bot_8c.html#a187b763475a2ab4f8505b2da8571e17b">More...</a><br /></td></tr>
<tr class="separator:a187b763475a2ab4f8505b2da8571e17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6643eadc8fa9d2d83fd8fd32670afcb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a6643eadc8fa9d2d83fd8fd32670afcb1">stack_push</a>(x1,  x2,  y,  dy)&#160;&#160;&#160;  <a class="el" href="bot_8c.html#abdf0972387a2b5e0a361d5db77f8a963">flood_fill_push</a>(&amp;stack, &amp;stack_len, &amp;stack_cap, x1, x2, y, dy, alloc_stack, data)</td></tr>
<tr class="separator:a6643eadc8fa9d2d83fd8fd32670afcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8f00d9b52e3fd29a7f0043bec46d5fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a8f00d9b52e3fd29a7f0043bec46d5fce">init_bot_parameters</a> (<a class="el" href="structBotParameters.html">BotParameters</a> *self)</td></tr>
<tr class="memdesc:a8f00d9b52e3fd29a7f0043bec46d5fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes all fields of the given <a class="el" href="structBotParameters.html" title="Various parameters for the bot algorithm.">BotParameters</a> to default values.  <a href="bot_8c.html#a8f00d9b52e3fd29a7f0043bec46d5fce">More...</a><br /></td></tr>
<tr class="separator:a8f00d9b52e3fd29a7f0043bec46d5fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6db63a2de47e95b3d7cc0965703d6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBotState.html">BotState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#acc6db63a2de47e95b3d7cc0965703d6a">bot_state_new</a> (const <a class="el" href="structBotParameters.html">BotParameters</a> *params, <a class="el" href="structGame.html">Game</a> *game, <a class="el" href="structRng.html">Rng</a> *rng)</td></tr>
<tr class="memdesc:acc6db63a2de47e95b3d7cc0965703d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="structBotState.html" title="Contains temporary data created during the evaluation of bot&#39;s moves.">BotState</a> (similarly <a class="el" href="structGame.html#ae95f3f05659adb948bd4c5eeabc04ad1" title="Constructs a Game. Allocates memory for storing the struct itself, setting all fields to default valu...">game_new</a>).  <a href="bot_8c.html#acc6db63a2de47e95b3d7cc0965703d6a">More...</a><br /></td></tr>
<tr class="separator:acc6db63a2de47e95b3d7cc0965703d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4606f35fae12e3db276a456072f7bd90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a4606f35fae12e3db276a456072f7bd90">bot_state_free</a> (<a class="el" href="structBotState.html">BotState</a> *self)</td></tr>
<tr class="memdesc:a4606f35fae12e3db276a456072f7bd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively destroys a <a class="el" href="structBotState.html" title="Contains temporary data created during the evaluation of bot&#39;s moves.">BotState</a> and its substates (similarly to <a class="el" href="structGame.html#af64165d4f5957d0d4ca0715f38082cc5" title="Destroys a Game, freeing the memory allocated for the struct itself and all associated internal lists...">game_free</a>).  <a href="bot_8c.html#a4606f35fae12e3db276a456072f7bd90">More...</a><br /></td></tr>
<tr class="separator:a4606f35fae12e3db276a456072f7bd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fd49c636f2d91394922f3135a6e90c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBotState.html">BotState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#ae8fd49c636f2d91394922f3135a6e90c">bot_enter_substate</a> (<a class="el" href="structBotState.html">BotState</a> *self)</td></tr>
<tr class="memdesc:ae8fd49c636f2d91394922f3135a6e90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates <a class="el" href="structBotState.html#a28bb94944a3bc3c8c15830ad9b208e1e" title="The link to the next recursive substate. Substates are allocated on demand by bot_enter_substate.">BotState::substate</a> if necessary and returns it.  <a href="bot_8c.html#ae8fd49c636f2d91394922f3135a6e90c">More...</a><br /></td></tr>
<tr class="separator:ae8fd49c636f2d91394922f3135a6e90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c45ae50259772b960afece11ac687d6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a8c45ae50259772b960afece11ac687d6">distance</a> (<a class="el" href="structCoords.html">Coords</a> start, <a class="el" href="structCoords.html">Coords</a> end)</td></tr>
<tr class="separator:a8c45ae50259772b960afece11ac687d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae02e58187427f86cb9f70fb22e1fce7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#aae02e58187427f86cb9f70fb22e1fce7">pick_best_score</a> (int scores_length, int *scores)</td></tr>
<tr class="separator:aae02e58187427f86cb9f70fb22e1fce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00dba948f3f7320057341a44ca383def"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a00dba948f3f7320057341a44ca383def">bot_compute_placement</a> (<a class="el" href="structBotState.html">BotState</a> *self, <a class="el" href="structCoords.html">Coords</a> *out_target)</td></tr>
<tr class="memdesc:a00dba948f3f7320057341a44ca383def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the best placement for the current player given the current game state.  <a href="bot_8c.html#a00dba948f3f7320057341a44ca383def">More...</a><br /></td></tr>
<tr class="separator:a00dba948f3f7320057341a44ca383def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f0daf2049bdd39652f489db565bf60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#af8f0daf2049bdd39652f489db565bf60">bot_rate_placement</a> (<a class="el" href="structBotState.html">BotState</a> *self, <a class="el" href="structCoords.html">Coords</a> penguin)</td></tr>
<tr class="memdesc:af8f0daf2049bdd39652f489db565bf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a score to the placement at the given coordinates.  <a href="bot_8c.html#af8f0daf2049bdd39652f489db565bf60">More...</a><br /></td></tr>
<tr class="separator:af8f0daf2049bdd39652f489db565bf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ca662bd40233c10ea853f87d01d81c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#ad9ca662bd40233c10ea853f87d01d81c">bot_compute_move</a> (<a class="el" href="structBotState.html">BotState</a> *self, <a class="el" href="structCoords.html">Coords</a> *out_penguin, <a class="el" href="structCoords.html">Coords</a> *out_target)</td></tr>
<tr class="memdesc:ad9ca662bd40233c10ea853f87d01d81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the best move for the current player given the current game state.  <a href="bot_8c.html#ad9ca662bd40233c10ea853f87d01d81c">More...</a><br /></td></tr>
<tr class="separator:ad9ca662bd40233c10ea853f87d01d81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ab8326a8d4fdf52efeb7a604706306"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structBotMove.html">BotMove</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a73ab8326a8d4fdf52efeb7a604706306">bot_generate_all_moves_list</a> (<a class="el" href="structBotState.html">BotState</a> *self, int penguins_count, <a class="el" href="structCoords.html">Coords</a> *penguins, int *moves_count)</td></tr>
<tr class="memdesc:a73ab8326a8d4fdf52efeb7a604706306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a list with all the possible moves (as <code>penguin -&gt; target</code> pairs) of the provided penguins.  <a href="bot_8c.html#a73ab8326a8d4fdf52efeb7a604706306">More...</a><br /></td></tr>
<tr class="separator:a73ab8326a8d4fdf52efeb7a604706306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de032b0515553e20e0bae6819c112d4"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a9de032b0515553e20e0bae6819c112d4">bot_rate_moves_list</a> (<a class="el" href="structBotState.html">BotState</a> *self, int moves_count, <a class="el" href="structBotMove.html">BotMove</a> *moves_list)</td></tr>
<tr class="memdesc:a9de032b0515553e20e0bae6819c112d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies <a class="el" href="structBotState.html#a6751a836b13b83085d4f3244d4cb29aa" title="The heart of the bot, assigns a score to the given move according to its usefulness.">bot_rate_move</a> to every move in the provided list and returns a pointer to the list of scores.  <a href="bot_8c.html#a9de032b0515553e20e0bae6819c112d4">More...</a><br /></td></tr>
<tr class="separator:a9de032b0515553e20e0bae6819c112d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6751a836b13b83085d4f3244d4cb29aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a6751a836b13b83085d4f3244d4cb29aa">bot_rate_move</a> (<a class="el" href="structBotState.html">BotState</a> *self, <a class="el" href="structBotMove.html">BotMove</a> move)</td></tr>
<tr class="memdesc:a6751a836b13b83085d4f3244d4cb29aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The heart of the bot, assigns a score to the given move according to its usefulness.  <a href="bot_8c.html#a6751a836b13b83085d4f3244d4cb29aa">More...</a><br /></td></tr>
<tr class="separator:a6751a836b13b83085d4f3244d4cb29aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a747f32f7aa32c607e6f069de2f485"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a90a747f32f7aa32c607e6f069de2f485">bot_quick_junction_check</a> (<a class="el" href="structBotState.html">BotState</a> *self, <a class="el" href="structCoords.html">Coords</a> coords)</td></tr>
<tr class="memdesc:a90a747f32f7aa32c607e6f069de2f485"><td class="mdescLeft">&#160;</td><td class="mdescRight">A precondition for junction checks to know if a more expensive flood fill test is necessary.  <a href="bot_8c.html#a90a747f32f7aa32c607e6f069de2f485">More...</a><br /></td></tr>
<tr class="separator:a90a747f32f7aa32c607e6f069de2f485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3d526ca872f1da98b7d63df3b1792a"><td class="memItemLeft" align="right" valign="top">short *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a7b3d526ca872f1da98b7d63df3b1792a">bot_flood_fill_reset_grid</a> (<a class="el" href="structBotState.html">BotState</a> *self, short **fill_grid, size_t *fill_grid_cap)</td></tr>
<tr class="memdesc:a7b3d526ca872f1da98b7d63df3b1792a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a grid for use in <a class="el" href="structBotState.html#ad06a633c0dcc623271d461298797a27c" title="Counts all fish accessible within an enclosed area starting at the given point using the flood fill a...">bot_flood_fill_count_fish</a> and fills it with zeroes.  <a href="bot_8c.html#a7b3d526ca872f1da98b7d63df3b1792a">More...</a><br /></td></tr>
<tr class="separator:a7b3d526ca872f1da98b7d63df3b1792a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf2da2da93ae906c47f90b4dea48ad9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a1bf2da2da93ae906c47f90b4dea48ad9">bot_flood_fill_check</a> (int x, int y, void *data)</td></tr>
<tr class="memdesc:a1bf2da2da93ae906c47f90b4dea48ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="structBotState.html#ad06a633c0dcc623271d461298797a27c" title="Counts all fish accessible within an enclosed area starting at the given point using the flood fill a...">bot_flood_fill_count_fish</a> and <a class="el" href="bot_8c.html#aa9f801ebdb0ce648c9d0cb0837139fb7" title="An implementation of flood fill using the span filling algorithm.">flood_fill</a>.  <a href="bot_8c.html#a1bf2da2da93ae906c47f90b4dea48ad9">More...</a><br /></td></tr>
<tr class="separator:a1bf2da2da93ae906c47f90b4dea48ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c22f56703a5618ce4541a26f903322"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a58c22f56703a5618ce4541a26f903322">bot_flood_fill_mark</a> (int x, int y, void *data)</td></tr>
<tr class="memdesc:a58c22f56703a5618ce4541a26f903322"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="structBotState.html#ad06a633c0dcc623271d461298797a27c" title="Counts all fish accessible within an enclosed area starting at the given point using the flood fill a...">bot_flood_fill_count_fish</a> and <a class="el" href="bot_8c.html#aa9f801ebdb0ce648c9d0cb0837139fb7" title="An implementation of flood fill using the span filling algorithm.">flood_fill</a>.  <a href="bot_8c.html#a58c22f56703a5618ce4541a26f903322">More...</a><br /></td></tr>
<tr class="separator:a58c22f56703a5618ce4541a26f903322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360123acc3c6024fd208b20224d65326"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structFillSpan.html">FillSpan</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#a360123acc3c6024fd208b20224d65326">bot_flood_fill_alloc_stack</a> (size_t capacity, void *data)</td></tr>
<tr class="memdesc:a360123acc3c6024fd208b20224d65326"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="structBotState.html#ad06a633c0dcc623271d461298797a27c" title="Counts all fish accessible within an enclosed area starting at the given point using the flood fill a...">bot_flood_fill_count_fish</a> and <a class="el" href="bot_8c.html#aa9f801ebdb0ce648c9d0cb0837139fb7" title="An implementation of flood fill using the span filling algorithm.">flood_fill</a>.  <a href="bot_8c.html#a360123acc3c6024fd208b20224d65326">More...</a><br /></td></tr>
<tr class="separator:a360123acc3c6024fd208b20224d65326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06a633c0dcc623271d461298797a27c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#ad06a633c0dcc623271d461298797a27c">bot_flood_fill_count_fish</a> (<a class="el" href="structBotState.html">BotState</a> *self, short *grid, <a class="el" href="structCoords.html">Coords</a> start, short marker_value)</td></tr>
<tr class="memdesc:ad06a633c0dcc623271d461298797a27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts all fish accessible within an enclosed area starting at the given point using the flood fill algorithm.  <a href="bot_8c.html#ad06a633c0dcc623271d461298797a27c">More...</a><br /></td></tr>
<tr class="separator:ad06a633c0dcc623271d461298797a27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf0972387a2b5e0a361d5db77f8a963"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#abdf0972387a2b5e0a361d5db77f8a963">flood_fill_push</a> (<a class="el" href="structFillSpan.html">FillSpan</a> **stack, size_t *stack_len, size_t *stack_cap, int x1, int x2, int y, int dy, <a class="el" href="structFillSpan.html">FillSpan</a> *(*alloc_stack)(size_t capacity, void *data), void *data)</td></tr>
<tr class="separator:abdf0972387a2b5e0a361d5db77f8a963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f801ebdb0ce648c9d0cb0837139fb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bot_8c.html#aa9f801ebdb0ce648c9d0cb0837139fb7">flood_fill</a> (int x, int y, bool(*check)(int x, int y, void *data), void(*mark)(int x, int y, void *data), <a class="el" href="structFillSpan.html">FillSpan</a> *(*alloc_stack)(size_t capacity, void *data), void *data)</td></tr>
<tr class="memdesc:aa9f801ebdb0ce648c9d0cb0837139fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of flood fill using the span filling algorithm.  <a href="bot_8c.html#aa9f801ebdb0ce648c9d0cb0837139fb7">More...</a><br /></td></tr>
<tr class="separator:aa9f801ebdb0ce648c9d0cb0837139fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a187b763475a2ab4f8505b2da8571e17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187b763475a2ab4f8505b2da8571e17b">&#9670;&nbsp;</a></span>bot_alloc_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define bot_alloc_buf</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buf, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">capacity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  ((size_t)1 * size &gt; capacity ? (buf = realloc(buf, sizeof(*buf) * size), capacity = size) : 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper for allocating the buffers cached within the <a class="el" href="structBotState.html" title="Contains temporary data created during the evaluation of bot&#39;s moves.">BotState</a>. </p>
<p>Checks if the buffer has enough capacity for data of the requested size, if not &ndash; reallocates it at the requested size. The <code>capacity</code> and <code>size</code> arguments are the number of elements (not the number of bytes), and are implicitly converted to <code>size_t</code> (the multiplication by 1 is used for that). </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00108">108</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="a6643eadc8fa9d2d83fd8fd32670afcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6643eadc8fa9d2d83fd8fd32670afcb1">&#9670;&nbsp;</a></span>stack_push</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define stack_push</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dy&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;  <a class="el" href="bot_8c.html#abdf0972387a2b5e0a361d5db77f8a963">flood_fill_push</a>(&amp;stack, &amp;stack_len, &amp;stack_cap, x1, x2, y, dy, alloc_stack, data)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8f00d9b52e3fd29a7f0043bec46d5fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f00d9b52e3fd29a7f0043bec46d5fce">&#9670;&nbsp;</a></span>init_bot_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_bot_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotParameters.html">BotParameters</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes all fields of the given <a class="el" href="structBotParameters.html" title="Various parameters for the bot algorithm.">BotParameters</a> to default values. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00031">31</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="classGamePanel.html#a3a9f9d1bf9b0695de8b8f50764631670">GamePanel::GamePanel()</a>.</p>

</div>
</div>
<a id="acc6db63a2de47e95b3d7cc0965703d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6db63a2de47e95b3d7cc0965703d6a">&#9670;&nbsp;</a></span>bot_state_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBotState.html">BotState</a> * bot_state_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structBotParameters.html">BotParameters</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGame.html">Game</a> *&#160;</td>
          <td class="paramname"><em>game</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRng.html">Rng</a> *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="structBotState.html" title="Contains temporary data created during the evaluation of bot&#39;s moves.">BotState</a> (similarly <a class="el" href="structGame.html#ae95f3f05659adb948bd4c5eeabc04ad1" title="Constructs a Game. Allocates memory for storing the struct itself, setting all fields to default valu...">game_new</a>). </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00042">42</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBotThread.html#aae37dd09ff483d6b3d4e9fefbb5757af">BotThread::BotThread()</a>.</p>

</div>
</div>
<a id="a4606f35fae12e3db276a456072f7bd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4606f35fae12e3db276a456072f7bd90">&#9670;&nbsp;</a></span>bot_state_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bot_state_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively destroys a <a class="el" href="structBotState.html" title="Contains temporary data created during the evaluation of bot&#39;s moves.">BotState</a> and its substates (similarly to <a class="el" href="structGame.html#af64165d4f5957d0d4ca0715f38082cc5" title="Destroys a Game, freeing the memory allocated for the struct itself and all associated internal lists...">game_free</a>). </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00075">75</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="ae8fd49c636f2d91394922f3135a6e90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fd49c636f2d91394922f3135a6e90c">&#9670;&nbsp;</a></span>bot_enter_substate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBotState.html">BotState</a> * bot_enter_substate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates <a class="el" href="structBotState.html#a28bb94944a3bc3c8c15830ad9b208e1e" title="The link to the next recursive substate. Substates are allocated on demand by bot_enter_substate.">BotState::substate</a> if necessary and returns it. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00094">94</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="a8c45ae50259772b960afece11ac687d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c45ae50259772b960afece11ac687d6">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCoords.html">Coords</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCoords.html">Coords</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The only distance function that is relevant for us since penguins can move only along the axes. </p><dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Taxicab_geometry">https://en.wikipedia.org/wiki/Taxicab_geometry</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00114">114</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="structBotState.html#a6751a836b13b83085d4f3244d4cb29aa">BotState::bot_rate_move()</a>, and <a class="el" href="structBotState.html#af8f0daf2049bdd39652f489db565bf60">BotState::bot_rate_placement()</a>.</p>

</div>
</div>
<a id="aae02e58187427f86cb9f70fb22e1fce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae02e58187427f86cb9f70fb22e1fce7">&#9670;&nbsp;</a></span>pick_best_score()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pick_best_score </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scores_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>scores</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00118">118</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="structBotState.html#ad9ca662bd40233c10ea853f87d01d81c">BotState::bot_compute_move()</a>, <a class="el" href="structBotState.html#a00dba948f3f7320057341a44ca383def">BotState::bot_compute_placement()</a>, and <a class="el" href="structBotState.html#a6751a836b13b83085d4f3244d4cb29aa">BotState::bot_rate_move()</a>.</p>

</div>
</div>
<a id="a00dba948f3f7320057341a44ca383def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00dba948f3f7320057341a44ca383def">&#9670;&nbsp;</a></span>bot_compute_placement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bot_compute_placement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCoords.html">Coords</a> *&#160;</td>
          <td class="paramname"><em>out_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the best placement for the current player given the current game state. </p>
<p>The algorithm for the placement phase is very simple:</p><ol type="1">
<li>Generate a list of valid tiles for placement.</li>
<li>Assign a score to every tile according to the rules in <a class="el" href="structBotState.html#af8f0daf2049bdd39652f489db565bf60" title="Assigns a score to the placement at the given coordinates.">bot_rate_placement</a>.</li>
<li>Pick the tile with the highest score.</li>
</ol>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the function managed to find a placement, <code>false</code> if there are no possible placements for the player or if the computation was cancelled. The coordinates of the resulting tile are written to <code>out_target</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00143">143</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBotPlacementThread.html#adff658d81bdfeb88236fd07d8eacaa28">BotPlacementThread::Entry()</a>.</p>

</div>
</div>
<a id="af8f0daf2049bdd39652f489db565bf60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f0daf2049bdd39652f489db565bf60">&#9670;&nbsp;</a></span>bot_rate_placement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bot_rate_placement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCoords.html">Coords</a>&#160;</td>
          <td class="paramname"><em>penguin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a score to the placement at the given coordinates. </p>
<p>Evaluates the nearby tiles to determine how good the placement location is. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00185">185</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="ad9ca662bd40233c10ea853f87d01d81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ca662bd40233c10ea853f87d01d81c">&#9670;&nbsp;</a></span>bot_compute_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bot_compute_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCoords.html">Coords</a> *&#160;</td>
          <td class="paramname"><em>out_penguin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCoords.html">Coords</a> *&#160;</td>
          <td class="paramname"><em>out_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the best move for the current player given the current game state. </p>
<p>The overall algorithm is roughly the following:</p>
<ol type="1">
<li>Generate a list of all possible moves with <a class="el" href="structBotState.html#a73ab8326a8d4fdf52efeb7a604706306" title="Creates a list with all the possible moves (as penguin -&gt; target pairs) of the provided penguins.">bot_generate_all_moves_list</a>.</li>
<li>Evaluate all moves in the list by calling <a class="el" href="structBotState.html#a9de032b0515553e20e0bae6819c112d4" title="Applies bot_rate_move to every move in the provided list and returns a pointer to the list of scores.">bot_rate_moves_list</a>.</li>
<li>Assign a score to every move using <a class="el" href="structBotState.html#a6751a836b13b83085d4f3244d4cb29aa" title="The heart of the bot, assigns a score to the given move according to its usefulness.">bot_rate_move</a>.<ol type="a">
<li>Some basic rules are considered first, such as: collecting more fish means a higher score, longer moves mean a lower score.</li>
<li>Then, rules for making the bot <em>aggressive</em> are applied: if the move resulted in blocking an opponent's penguin, its score is increased dramatically.</li>
<li>The scores of obviously stupid moves (such as blocking yourself with your own penguin) are reduced significantly so as to not take them seriously.</li>
<li>And lastly, the most important part of the algorithm takes place: the move is applied to the <a class="el" href="structGame.html" title="The central struct of the application, holds the game data and settings.">Game</a> instance, and the algorithm is repeated recursively from step 1 (generate a list of all moves available from there, assign scores to each and so on and so on). The best next move is selected and its score is added to the score of the currently considered move &ndash; this allows the bot to see future opportunities, including locating and blocking other penguins, which makes it REALLY aggressive (sometimes, though rarely, it even can discover combos). Afterwards, the applied move is undone.</li>
</ol>
</li>
<li>Finally, the move with the highest is selected and returned.</li>
</ol>
<p>Note that when evaluating moves recursively, the provided <a class="el" href="structGame.html" title="The central struct of the application, holds the game data and settings.">Game</a> is modified instead of creating a copy of it each time. However, recursive evaluation currently has a significant limitation &ndash; it only considers sequences of moves of a single penguin, and doesn't take the opponents' moves into account at all (doing otherwise consumes too much computing time).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a move was found, <code>false</code> if there were no moves available for the player or if the computation was cancelled. If found, the move is written to <code>out_penguin</code> and <code>out_target</code>.</dd></dl>
<p>The aggressive strategy proved to be very effective against other bots, which are usually passive (meaning that they simply try to collect fish) - it first blocks all other players and then collects the rest of the fish. It is even somewhat effective against humans because its aggressiveness essentially relies on the opponent making a mistake, which is not an unreasonable assumption when playing against a human (especially myself). Although, consequently, the stupidest bots, which are simply making literally the first available move after scanning the board (this is what the <a class="el" href="bot_8h.html#ade68828b6d9ea694fb9a344ffc2ab875a6dce1228ca09e14ab7e440c884e34fd3" title="Pick the first possible move (also known as the &quot;dumb&quot; algorithm).">BOT_MOVEMENT_FIRST_POSSIBLE</a> strategy does), ended up being the algorithm's fatal weakness (well, not exactly fatal, it can still win against those) &ndash; primarily because they are very persistent at just moving in a single direction. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00295">295</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="classBotMovementThread.html#aee00935e59756a2c84d40154cf7db3a6">BotMovementThread::Entry()</a>.</p>

</div>
</div>
<a id="a73ab8326a8d4fdf52efeb7a604706306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ab8326a8d4fdf52efeb7a604706306">&#9670;&nbsp;</a></span>bot_generate_all_moves_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structBotMove.html">BotMove</a> * bot_generate_all_moves_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>penguins_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCoords.html">Coords</a> *&#160;</td>
          <td class="paramname"><em>penguins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>moves_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a list with all the possible moves (as <code>penguin -&gt; target</code> pairs) of the provided penguins. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the resulting list, whose length is written to the <code>moves_count</code> argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00330">330</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="a9de032b0515553e20e0bae6819c112d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de032b0515553e20e0bae6819c112d4">&#9670;&nbsp;</a></span>bot_rate_moves_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * bot_rate_moves_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>moves_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBotMove.html">BotMove</a> *&#160;</td>
          <td class="paramname"><em>moves_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies <a class="el" href="structBotState.html#a6751a836b13b83085d4f3244d4cb29aa" title="The heart of the bot, assigns a score to the given move according to its usefulness.">bot_rate_move</a> to every move in the provided list and returns a pointer to the list of scores. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00369">369</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="a6751a836b13b83085d4f3244d4cb29aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6751a836b13b83085d4f3244d4cb29aa">&#9670;&nbsp;</a></span>bot_rate_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bot_rate_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structBotMove.html">BotMove</a>&#160;</td>
          <td class="paramname"><em>move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The heart of the bot, assigns a score to the given move according to its usefulness. </p>
<p>In case a cancellation is requested (see <a class="el" href="structBotState.html#aa9187019d4fb667608b042bdf72a871f" title="Can be set to true from another thread to cancel the move evaluation.">BotState::cancelled</a>), this function starts unwinding the recursive calls and returns some garbage score, but otherwise the move computation is stopped. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00433">433</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="a90a747f32f7aa32c607e6f069de2f485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a747f32f7aa32c607e6f069de2f485">&#9670;&nbsp;</a></span>bot_quick_junction_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bot_quick_junction_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCoords.html">Coords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A precondition for junction checks to know if a more expensive flood fill test is necessary. </p>
<p>A "junction" is a state when then bot has to choose between two or more directions because once it makes a move the other paths will become inaccessible. This function only performs a quick heuristic check which can only tell if the current tile is <em>definitely not</em> a junction, so it is used to know if a further more time-consuming flood fill test is necessary. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00565">565</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="a7b3d526ca872f1da98b7d63df3b1792a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3d526ca872f1da98b7d63df3b1792a">&#9670;&nbsp;</a></span>bot_flood_fill_reset_grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short * bot_flood_fill_reset_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short **&#160;</td>
          <td class="paramname"><em>fill_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>fill_grid_cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a grid for use in <a class="el" href="structBotState.html#ad06a633c0dcc623271d461298797a27c" title="Counts all fish accessible within an enclosed area starting at the given point using the flood fill a...">bot_flood_fill_count_fish</a> and fills it with zeroes. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00620">620</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="a1bf2da2da93ae906c47f90b4dea48ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf2da2da93ae906c47f90b4dea48ad9">&#9670;&nbsp;</a></span>bot_flood_fill_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool bot_flood_fill_check </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="structBotState.html#ad06a633c0dcc623271d461298797a27c" title="Counts all fish accessible within an enclosed area starting at the given point using the flood fill a...">bot_flood_fill_count_fish</a> and <a class="el" href="bot_8c.html#aa9f801ebdb0ce648c9d0cb0837139fb7" title="An implementation of flood fill using the span filling algorithm.">flood_fill</a>. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00638">638</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="a58c22f56703a5618ce4541a26f903322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c22f56703a5618ce4541a26f903322">&#9670;&nbsp;</a></span>bot_flood_fill_mark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void bot_flood_fill_mark </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="structBotState.html#ad06a633c0dcc623271d461298797a27c" title="Counts all fish accessible within an enclosed area starting at the given point using the flood fill a...">bot_flood_fill_count_fish</a> and <a class="el" href="bot_8c.html#aa9f801ebdb0ce648c9d0cb0837139fb7" title="An implementation of flood fill using the span filling algorithm.">flood_fill</a>. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00651">651</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="a360123acc3c6024fd208b20224d65326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360123acc3c6024fd208b20224d65326">&#9670;&nbsp;</a></span>bot_flood_fill_alloc_stack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structFillSpan.html">FillSpan</a> * bot_flood_fill_alloc_stack </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See <a class="el" href="structBotState.html#ad06a633c0dcc623271d461298797a27c" title="Counts all fish accessible within an enclosed area starting at the given point using the flood fill a...">bot_flood_fill_count_fish</a> and <a class="el" href="bot_8c.html#aa9f801ebdb0ce648c9d0cb0837139fb7" title="An implementation of flood fill using the span filling algorithm.">flood_fill</a>. </p>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00661">661</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="ad06a633c0dcc623271d461298797a27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06a633c0dcc623271d461298797a27c">&#9670;&nbsp;</a></span>bot_flood_fill_count_fish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bot_flood_fill_count_fish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structBotState.html">BotState</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCoords.html">Coords</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>marker_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts all fish accessible within an enclosed area starting at the given point using the flood fill algorithm. </p>
<p>Returns the number of reachable fish, the counted tiles are marked on the provided fill grid with <code>marker_value</code>, which must be non-zero. Additionally is used for junction checks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="bot_8c.html#aa9f801ebdb0ce648c9d0cb0837139fb7" title="An implementation of flood fill using the span filling algorithm.">flood_fill</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00677">677</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="abdf0972387a2b5e0a361d5db77f8a963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf0972387a2b5e0a361d5db77f8a963">&#9670;&nbsp;</a></span>flood_fill_push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void flood_fill_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFillSpan.html">FillSpan</a> **&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>stack_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>stack_cap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFillSpan.html">FillSpan</a> *(*)(size_t capacity, void *data)&#160;</td>
          <td class="paramname"><em>alloc_stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00690">690</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

</div>
</div>
<a id="aa9f801ebdb0ce648c9d0cb0837139fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f801ebdb0ce648c9d0cb0837139fb7">&#9670;&nbsp;</a></span>flood_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flood_fill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int x, int y, void *data)&#160;</td>
          <td class="paramname"><em>check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int x, int y, void *data)&#160;</td>
          <td class="paramname"><em>mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFillSpan.html">FillSpan</a> *(*)(size_t capacity, void *data)&#160;</td>
          <td class="paramname"><em>alloc_stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An implementation of flood fill using the span filling algorithm. </p>
<p>This is essentially the algorithm behind the "bucket" tool in paint programs. The code was pretty much copied (and translated from pseudocode) from Wikipedia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the starting point </td></tr>
    <tr><td class="paramname">y</td><td>the starting point </td></tr>
    <tr><td class="paramname">check</td><td>a function that returns <code>true</code> if the given cell should be marked </td></tr>
    <tr><td class="paramname">mark</td><td>a function that marks the given cell </td></tr>
    <tr><td class="paramname">alloc_stack</td><td>a function that allocates that stack for <a class="el" href="structFillSpan.html" title="Used internally by flood_fill.">FillSpan</a> s </td></tr>
    <tr><td class="paramname">data</td><td>extra data to be passed into the provided functions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Flood_fill#Span_Filling">https://en.wikipedia.org/wiki/Flood_fill#Span_Filling</a> </dd>
<dd>
<a href="https://github.com/erich666/GraphicsGems/blob/c3263439c281da62df4a559ec8164cf8c9eb88ca/gems/SeedFill.c">https://github.com/erich666/GraphicsGems/blob/c3263439c281da62df4a559ec8164cf8c9eb88ca/gems/SeedFill.c</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="bot_8c_source.html#l00725">725</a> of file <a class="el" href="bot_8c_source.html">bot.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="structBotState.html#ad06a633c0dcc623271d461298797a27c">BotState::bot_flood_fill_count_fish()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="bot_8c.html">bot.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
